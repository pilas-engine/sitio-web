<!DOCTYPE html>
<html lang="en-us">
    <head>
        


        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="shortcut icon" type="image/png" href="https://pilas-engine.github.io/sitio-web/favicon.png">
        
        <title></title>

        <style>
</style>


<link rel="stylesheet" href="https://pilas-engine.github.io/sitio-web/css/main.css">
<link rel="stylesheet" href="https://pilas-engine.github.io/sitio-web/css/tachyons.min.css">





        


<script src="https://pilas-engine.github.io/sitio-web/js/main.js"></script>
 
        <meta name="generator" content="Hugo 0.84.4" />

        


        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-5829629-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-5829629-2');
        </script>

    </head>

    <body>
        

        <nav class="db w-100 shadow-1 border-box pa0 sans-serif flex items-center">

  <a href="https://pilas-engine.github.io/sitio-web/" class="v-mid mid-gray link w5 pl3 pv2" href="#" title="home">
    <img class="logo" width="183" height="64" src="https://pilas-engine.github.io/sitio-web/logo-de-pilas.svg">
  </a>

  <div class="v-mid w-100 tr truncate">
    <a class="link source-sans-pro dim dark-gray f5 dib mr1-l ph2 pt3 pb3" href="https://pilas-engine.github.io/sitio-web/">Principal</a>
    <a class="link source-sans-pro dim dark-gray f5 dib mr1-l ph2 pt3 pb3" href="https://pilas-engine.github.io/sitio-web/noticias">Noticias</a>
    <a class="link source-sans-pro dim dark-gray f5 dib mr1-l ph2 pt3 pb3" href="https://pilas-engine.github.io/sitio-web/descargas">Descargas</a>
    <a class="link source-sans-pro dim dark-gray f5 dib mr1-l ph2 pt3 pb3" href="https://pilas-engine.github.io/sitio-web/documentacion">Documentación</a>
    <a class="link source-sans-pro dim dark-gray f5 dib mr1-l ph2 pt3 pb3" href="https://pilas-engine.github.io/sitio-web/foro">Foro</a>
    <a class="link source-sans-pro dim dark-gray f5 dib mr1-l ph2 pt3 pb3" href="https://pilas-engine.github.io/sitio-web/videos">Videos</a>
    <a class="link source-sans-pro dim dark-gray f5 dib mr1-l ph2 pt3 pb3" href="https://pilas-engine.github.io/sitio-web/galeria">Galería</a>
  </div>

</nav>



<style>
  .tutorial h1 {
    color: #005590;
  }

  .tutorial code {
    color: black;
    background-color: #dcdcdc;
    padding: 3px 5px;
    font-family: monospace;
  }

  .tutorial h2 {
    color: #005590;
  }

  .tutorial p {
  }

  .tutorial strong {
    font-weight: bold;
  }

  .tutorial li {
    text-align: justify;
  }

  .tutorial img {
    max-width: 100%;
    display: block;
    padding: 1em;
    margin: auto;
  }

  .footer_imprimir {
    display: none;
  }
</style>



<style media="print">
  header {
    display: none !important;
  }

  body {
    overflow: initial !important;
  }

  .contenedor-scroll {
    position: initial !important;
    overflow: initial !important;
    top: initial !important;
    left: initial !important;
    right: initial !important;
    bottom: initial !important;
  }

  footer {
    display: none;
  }

  .footer_imprimir {
    display: block !important;
  }

  .contenedor-para-el-boton-imprimir {
    display: none;
  }

</style>




<div class="contenedor-scroll">
  <main class="tutorial pt4 mw7 center ph2 sans-serif pb4 lh-copy" aria-label="Content">

    <div class="tr f6">
      <div class="pt3 contenedor-para-el-boton-imprimir">
        <button type="button" onclick="window.print(); return false;">Imprimir tutorial</button>
      </div>
    </div>

    <h1 id="cómo-crear-el-videojuego-arkanoid">Cómo crear el videojuego Arkanoid</h1>
<p>En este tutorial desarrollaremos un juego inspirado en el clásico Arkanoid,
este típico juego donde hay una pequeña plataforma que impide que una bola
salga de la zona de juego, haciéndola rebotar, y en la parte superior hay
ladrillos o bloques, que desaparecen al ser tocados por la bola, pero con la
particularidad de que necesitan un número de toques para desaparecer.</p>
<h2 id="primer-paso">Primer paso</h2>
<p>Abrimos el editor de Pilas, borramos los actores que tengamos inicialmente para
tener el escenario limpio y poder comenzar a trabajar.</p>
<p><img src="image39.png" alt=""></p>
<p>Vamos a configurar el escenario de juego, le agregaremos un fondo (que puede
ser el que queramos) y le daremos un nombre. Para eso seleccionamos la
<em>“escena1”</em> y vamos a modificar sus atributos.</p>
<p><img src="image33.png" alt=""></p>
<p>En este caso, llamaremos a la escena <em>“escena_juego”</em> y seleccionaremos un
fondo con madera para darle ambiente a nuestro juego.</p>
<p><img src="image45.png" alt=""></p>
<p>Crearemos los bloques del juego, seleccionamos el botón <em>“Crear actor”,</em> al
presionar este botón se nos abrirá la siguiente ventana y seleccionaremos la
opción <em>“actor”</em>.</p>
<p><img src="image31.png" alt=""></p>
<p>Esta opción nos permitirá elegir el aspecto que le queramos dar y podremos
configurarlo como nos sea más útil. En este caso, le colocaremos de nombre
<em>“bloque”</em>, como imagen usaremos la que se denomina <em>“bloque_arkanoid_azul”</em>
y lo colocaremos en la parte superior para tener más visibilidad de lo que
estamos trabajando, se pueden desplazar los actores seleccionandolo en la
ventana y arrastrándolo al lugar que querramos.</p>
<p><img src="image4.png" alt=""></p>
<p>Este bloque será nuestra plantilla, ya que necesitamos varios de ellos y si la
pelotita lo toca, las veces requeridas, desaparecerá. Para que haya muchos de
él, nos dirigiremos al código de la escena del juego, seleccionaremos
<em>“escena_juego”</em> desde el sector <em>“Escena y actores”</em>, y dentro de su código
colocaremos lo siguiente dentro del método <em>“iniciar()”</em>.</p>
<p><img src="image8.png" alt=""></p>
<p>Este código hará que al iniciar la escena de juego, se clone el actor
<em>“bloque”</em> varias veces en las posiciones indicadas. Se utilizan dos ciclos for
anidados que se encargaran de esto.</p>
<p>Para que este código funcione, dentro de las propiedades del bloque, le
agregaremos como <em>“Etiqueta”</em> un nombre, en este caso, le pondremos bloque.
Además, como la generación de este actor la realizamos por código, dentro de
sus propiedades desactivaremos <em>“Activo”</em>, y para que no se caigan, es decir,
respete la gravedad, también desactivaremos la propiedad <em>“Dinámica”.</em></p>
<p><img src="image28.png" alt=""></p>
<p>Con esto tendremos los bloques estacionarios que deberemos eliminar con nuestra
pelotita.</p>
<p><img src="image42.png" alt=""></p>
<h2 id="segundo-paso">Segundo paso</h2>
<p>Crearemos la paleta que controlará el jugador y nos permitirá que la pelotita
no se caiga. Para esto, crearemos un actor de tipo <em>“actor”</em> como hicimos con
el bloque. Le cambiaremos las siguientes propiedades:</p>
<p><img src="image22.png" alt=""></p>
<p>Agregando un nombre, una imagen, donde se encontrará en la pantalla y haciendo
que no se caiga desactivando la propiedad <em>“Dinámico”.</em></p>
<p>Teniendo el actor paleta seleccionado, podemos editar su código para darle
comportamiento.</p>
<p><img src="image3.png" alt=""></p>
<p>En el código, le daremos movimiento a la paleta dentro de su método
<em>“actualizar()”</em>, colocando una velocidad a la cual se va a desplazar este
actor, su movimiento sólo será de forma horizontal, y para que no salga de
nuestra pantalla limitaremos dicho movimiento.</p>
<p><img src="image13.png" alt=""></p>
<h2 id="tercer-paso">Tercer paso</h2>
<p>Crearemos la pelotita con la cual podremos destruir los bloques. Esto lo
realizaremos como con los anteriores actores, creando un actor de tipo
<em>“actor”</em> y definiendo las siguientes propiedades:</p>
<p><img src="image36.png" alt=""></p>
<p>Este actor tendrá una habilidad dentro de sus propiedades, que hará que la
pelotita oscile en su movimiento inicial. Para ello nos dirigimos a la
propiedad <em>“Habilidades”</em> y le colocamos <em>“oscilar rotación”.</em></p>
<p><img src="image47.png" alt=""></p>
<p>En Arkanoid siempre hay que presionar una tecla para comenzar el juego, ya que
podemos posicionarnos en diferentes lugares para que la pelotita se dirija
hacia donde nosotros deseamos. Para ello, haremos que el jugador deba presionar
la barra espaciadora para que la pelotita comience a moverse.</p>
<p>Pero debemos colocar una restricción, la funcionalidad de la barra espaciadora
sólo debe permitirse al comienzo del juego, es por ello, que le colocaremos a
la paleta una fase <em>“inicio”.</em></p>
<p><img src="image21.png" alt=""></p>
<p>En este estado, la pelotita deberá seguir el movimiento de la paleta,
colocaremos esto dentro del código de la paleta en el método <em>“actualizar()”</em>
de la siguiente manera:</p>
<p><img src="image40.png" alt=""></p>
<p>Ahora haremos que la pelotita salga disparada de la paleta cuando se presione
la barra espaciadora. Esta funcionalidad se la colocaremos a la paleta dentro
de un método que viene predefinido que se llama <em>“cuando_pulsa_tecla()”</em>.</p>
<p><img src="image41.png" alt=""></p>
<p>Este método pregunta si estamos en la fase de inicio, y si se presiona la barra
espaciadora le envía a la pelotita un mensaje para que ésta comience su
movimiento.</p>
<p>Vamos al código de la pelotita a colocar su funcionamiento de desplazamiento y
que se quede estacionaria hasta que reciba el mensaje de la paleta de que puede
empezar a moverse.</p>
<p>La parte relacionada al mensaje de la paleta lo pondremos en un método que
posee pilas predefinido que es <em>“cuando_llega_el_mensaje_empujar()”</em> de la
siguiente manera.</p>
<p><img src="image43.png" alt=""></p>
<p>Y su movimiento en el método <em>“actualizar()”</em> utilizando los valores definidos
dentro del método anterior, si no recibiera el mensaje de la paleta, la
pelotita no tendría velocidad y por ello no se movería.</p>
<p><img src="image38.png" alt=""></p>
<p>Para que todo esto funcione, la pelotita debe poseer figura física, así que se
la agregaremos modificando sus propiedades en la sección <em>“Simulación física”</em>.
Como figura le colocaremos un círculo y le ajustaremos el tamaño para que se
adapte al que posee nuestro actor.</p>
<p><img src="image27.png" alt=""></p>
<p>Ya que estamos en ello, también realizaremos lo mismo con los demás actores,
eligiendo la figura que más se adapte y modificando su tamaño para que coincida
con los mismos.</p>
<p>Como vemos, los actores ahora poseen un contorno de color azul por no ser dinámicos.</p>
<p><img src="image5.png" alt=""></p>
<p>Para informar al jugador que debe presionar la barra espaciadora para comenzar
a jugar, le colocaremos un mensaje informando ésto. Crearemos un actor del tipo
<em>“texto”</em>, y le cambiaremos las siguientes propiedades:</p>
<p><img src="image35.png" alt=""></p>
<p>Y cuando el jugador presione la barra espaciadora, este mensaje deberá
desaparecer. Para ello, agregamos en el código de la paleta un nuevo método,
que llamaremos <em>“eliminar_mensaje()”.</em></p>
<p><img src="image12.png" alt=""></p>
<p>Este método lo llamaremos dentro de <em>“cuando_pulsa_tecla()”,</em> ya que aquí es cuando el jugador presiona la barra espaciadora.</p>
<p><img src="image26.png" alt=""></p>
<p>Como vemos, la pelotita sigue a nuestra paleta hasta que presionamos la barra espaciadora. Pero al hacer esto puede salir por los laterales, para que esto no ocurra vamos a crear un método que controle que la pelotita no salga del límite de la pantalla multiplicando la velocidad de la misma por -1 para que cambie su dirección en el horizontal, es decir, el eje x. Lo mismo para el eje y, pero solo cuando toca el límite superior, ya que si cruza el límite inferior el jugador perdería.</p>
<p><img src="image25.png" alt=""></p>
<p>Además, para que este método sea invocado, lo incluiremos dentro del método <em>“actualizar()”</em> de la pelotita.</p>
<p><img src="image46.png" alt=""></p>
<h2 id="cuarto-paso">Cuarto paso</h2>
<p>Ahora, lo que realizaremos son las colisiones entre la pelotita con la paleta y
con los bloques. Primero nos enfocaremos a la colisión con la paleta.</p>
<p>Dentro del código de la pelotita crearemos otro método que se encargará de la
funcionalidad de la colisión de la misma con la paleta de la siguiente manera.
Primero, cuando la pelotita está por colisionar con la paleta, verificamos si
esta última está en posición de poder empujar la pelotita hacia arriba o no.
Luego, comprobamos si la pelotita está colisionando con la paleta, y de ser
así, hacemos que quede justo en contacto con ella, invirtiendo el sentido de su
movimiento vertical. De esta forma se dá el efecto de que la pelotita está
rebotando en la paleta. Por último, modificamos la velocidad horizontal de la
pelotita en base a la parte de la paleta con la que colisionó.</p>
<p><img src="image23.png" alt=""></p>
<p>Este método, al igual que con el del paso anterior, hay que invocarlo dentro de
<em>“actualizar()”.</em></p>
<p><img src="image20.png" alt=""></p>
<p>Siguiendo con las colisiones, vamos a agregar la funcionalidad de colisión
entre la pelotita y los bloques. Por un lado, debemos controlar ese movimiento,
y para ello, agregamos un método predefinido dentro del código de la pelotita
que redireccionará a la misma dependiendo de qué lado del bloque toque.</p>
<p><img src="image18.png" alt=""></p>
<h2 id="quinto-paso">Quinto paso</h2>
<p>Haremos que el jugador pueda perder, si no logra hacer que la pelotita rebote
en la paleta. Esto lo haremos en una nueva escena que crearemos, vamos a
<em>“Crear Escena”</em> y le pondremos como nombre <em>“escena_perdio”.</em></p>
<p><img src="image44.png" alt=""></p>
<p>Crearemos un actor del tipo <em>“texto”</em>, para informar al jugador que ha perdido,
y lo colocaremos donde se desee dentro de la escena.</p>
<p><img src="image15.png" alt=""></p>
<p>Además, agregaremos otro actor que nos permita reiniciar la escena y volver a
jugar, este actor será de tipo <em>“reiniciar_escena”</em> que está predefinido, por
lo tanto, no tendremos que modificar ninguna de sus propiedades.</p>
<p><img src="image14.png" alt=""></p>
<p>Para darle más impacto a esta situación, haremos que la paleta dé el efecto de
una explosión al perder la pelotita y, por ende, el juego. Crearemos para ello,
un actor del tipo <em>“explosion”</em> que también está predefinido, lo moveremos de
posición solo para poder verlo en la creación de la escena.</p>
<p><img src="image30.png" alt=""></p>
<p>Agregaremos un nuevo método en el código de la pelotita para que cuando la
misma salga fuera de la pantalla por el límite inferior, el jugador pierda.
Este método informa que el jugador ha perdido, y la escena se encargará del
resto.</p>
<p><img src="image32.png" alt=""></p>
<p>Este método, al igual que con otros que hemos realizado, hay que invocarlo
dentro de “actualizar()”.</p>
<p><img src="image37.png" alt=""></p>
<p>Como dijimos, debemos agregar funcionalidad en la escena de juego utilizando un
nuevo método que traerá los elementos que creamos en la <em>“escena_perdio”</em> para
informar al jugador dicha situación y le permita reiniciar el juego. además,
coloca la explosión donde se encontraba la paleta en el momento que la pelotita
salió de la pantalla, dando el efecto de que explota.</p>
<p><img src="image16.png" alt=""></p>
<h2 id="sexto-paso">Sexto paso</h2>
<p>Crearemos otra escena, esta vez para representar que el jugador ha ganado, lo
cual sucede cuando todos los bloques son eliminados. Además, colocaremos un
contador que indique la cantidad de bloques restantes, para darle información
al jugador. Esto último lo haremos creando un actor de tipo <em>“texto”</em> dentro de
la escena de juego, al cual llamaremos <em>“contador_bloques”</em> y colocaremos en
la parte superior.</p>
<p><img src="image10.png" alt=""></p>
<p>Dentro de su código, colocaremos el siguiente método para que se actualice cada
vez que se elimine un bloque. Ve cuántos bloques hay en la pantalla y muestra
ese valor junto con un mensaje. Ojo: se utiliza comilla invertida (`) en la
línea 5.</p>
<p><img src="image24.png" alt=""></p>
<p>Para avisar a este actor que se ha eliminado un bloque, dentro del código de la
pelotita, en el método <em>“cuando_colisiona()”</em>, incluiremos lo siguiente:</p>
<p><img src="image9.png" alt=""></p>
<p>Con esto hecho, crearemos una escena para que, cuando no haya más bloques,
muestre un mensaje al jugador avisándole que ha ganado. Llamaremos a este actor
<em>“escena_gano”</em>.</p>
<p><img src="image2.png" alt=""></p>
<p>Dentro de esta escena crearemos otro actor del tipo <em>“texto”,</em> que llamaremos
<em>“mensaje_ganaste”</em> y le colocaremos las siguientes propiedades:</p>
<p><img src="image7.png" alt=""></p>
<p>Por último, dentro del código de la escena del juego, llamaremos a este mensaje
cuando no queden bloques por eliminar. Para ello, utilizamos el método que se
envía cada vez que se elimina un bloque
<em>“cuando_llega_el_mensaje_elimina_bloque()”.</em></p>
<p><img src="image17.png" alt=""></p>
<p>Podemos probar nuestro juego dando en el botón <em>“Ejecutar”</em>.</p>
<h2 id="séptimo-paso">Séptimo paso</h2>
<p>Como podemos observar, hemos hecho un arkanoid clásico muy similar a uno de los
ejemplos que posee pilas-engine. Como dijimos al principio, la versión de
arkanoid que queremos diseñar requiere que los bloques sean tocados una cierta
cantidad de veces para ser eliminados, y esta funcionalidad es la que
desarrollaremos en este último paso.</p>
<p>Primero, crearemos un nuevo actor del tipo <em>“texto”</em>, le colocaremos como
nombre <em>“vida_bloque”</em> y le desactivaremos la propiedad de activo, ya que es
una plantilla, y haremos más por código como con los bloques. Sus propiedades
nos deben quedar de la siguiente manera.</p>
<p><img src="image19.png" alt=""></p>
<p>La generación de estas vidas las incluiremos en el código de la escena del
juego, generando las mismas en las posiciones de los bloques de la siguiente
manera.</p>
<p><img src="image1.png" alt=""></p>
<p>Como este actor representa las vidas del bloque, al iniciarse necesitamos que
posea un valor numérico y lo muestre. Para ello, en su código colocaremos el
método <em>“iniciar”</em> y en su contenido generaremos un número al azar entre el 1 y
5 (estos valores pueden modificarse a gusto) de la siguiente manera.</p>
<p><img src="image6.png" alt=""></p>
<p>Dentro del código de la pelotita, crearemos un nuevo método llamado
<em>“actualizar_vida_bloque(actor: Actor)”</em> que tendrá como parámetro un actor,
en este caso el bloque con el cual colisiona, que tendrá la nueva funcionalidad
de disminuir las vidas del bloque hasta eliminarlo. Este método busca los
actores en la posición del actor, que en este caso son el bloque que se pasó
como parámetro y su actor vida, por lo tanto, este arreglo contendrá 2 actores,
<em>“bloque”</em> y <em>“vida_bloque”</em>. Nosotros necesitamos la vida del bloque, por
ello buscamos en qué posición del arreglo está. Una vez que obtenemos el actor
<em>“vida_bloque”</em>, actualizamos su valor, y si es cero eliminamos tanto al
bloque como su vida.</p>
<p><img src="image11.png" alt=""></p>
<p>Además, crearemos otro método al que llamaremos <em>“reposicionar()”</em> dentro del
código de la pelotita. Este método nos ayuda a despegar la pelotita del bloque
cuando colisionan, utilizando la misma velocidad con la que se mueve, para que
no se produzcan múltiples colisiones al mismo tiempo debido que el bloque no se
eliminó.</p>
<p><img src="image29.png" alt=""></p>
<p>Por último, utilizaremos los 2 métodos anteriormente creados para modificar la
funcionalidad que realiza hasta ahora nuestro juego. Para ello, modificaremos
el método <em>“cuando_coliciona(actor: Actor)”</em> reemplazando la parte que
eliminaba el bloque por los nuevos métodos, y eliminando el mensaje global de
que el bloque fue eliminado, ya que el mismo ahora se encuentra en el método
<em>“actualizar_vida_bloque(actor: Actor)”</em> debido a que los bloques ahora
poseen vidas y eventualmente se eliminan ahí.</p>
<p><img src="image34.png" alt=""></p>
<p>Podemos probar nuestro juego dando en el botón <em>“Ejecutar”</em>.</p>
<p>Esto es todo, de esta forma ya tenemos un pequeño juego del típico Arkanoid, el
cual se puede mejorar incluyendo nuevas funcionalidades o haciendo más visible
el código.</p>
<p>¡Muchas gracias!</p>


    <div class="footer_imprimir tc">
      Artículo extraído del sitio <a href="https://www.pilas-engine.com.ar">https://www.pilas-engine.com.ar</a>
    </div>

            <footer class="pt4 ph3 ph5-m ph6-l mid-gray sans-serif pv3">

          <div class="tc mt3">
            <a href="https://github.com/pilas-engine/pilas-engine/" target=_blank title="github" class="mh2 f6 dib ph2 link mid-gray dim"><img src="https://pilas-engine.github.io/sitio-web/iconos/github.png"></a>
            <a href="https://www.youtube.com/user/hugoruscitti" target=_blank title="youtube" class="mh2 f6 dib ph2 link mid-gray dim"><img src="https://pilas-engine.github.io/sitio-web/iconos/youtube.png"></a>
            <a href="https://foro.pilas-engine.com.ar/" target=_blank title="foro" class="mh2 f6 dib ph2 link mid-gray dim"><img src="https://pilas-engine.github.io/sitio-web/iconos/foro.png"></a>
          </div>

          <div class="tc mt2 f7">
            © Hugo Ruscitti
          </div>

        </footer>

        

        
    </body>

</html>


  </main>
</div>

